= Security SSL encryption and authorization tutorial

This tutorial will show you how to use certificates to verify the client connects the correct server and the traffic is encrypted.
With additional steps the server can also verify that the client is allowed to connect as well this certificate can be used for authorization.


For more information about encryption and certificate configuration please refer to:
* link:https://infinispan.org/docs/stable/titles/server/server.html#server_identity[Infinispan Server Guide - Server Identities]
* link:https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html#configuring-hotrod-encryption_hotrod-client-configuration[HotRod Java client guide - Encryption]
* link:https://infinispan.org/docs/stable/titles/hotrod_java/hotrod_java.html#configuring-hotrod-authentication_hotrod-client-configuration[HotRod Java client guide - Authentication]

== Building instructions and preparation

* Invoke `mvn clean package`
* Build the example certificates and keystores by using the scripts or keytool commands directly
   * create_unsigned_certificates.sh
   * create_signed_certificates.sh
   As result there are some keystores and truststores build in the directory which are necessary for the server or client running the next steps.
   Note the client will try to connect the server with all different methods and show which method is working.
* [Download the latest Infinispan server](https://infinispan.org/download/)
* Add a cache named secured
```xml
   <cache-container name="default" ...>
      ...
      <local-cache name="secured"/>
   </cache-container>
```

== Simple unsigned server keystore

=== Apply the configuration
* copy server-keystore.pfx to ${ISPN_HOME}/server/conf
* Add the `server-identities` element as followed, note that the properties realm is removed
```xml
       <security-realm name="default">
         <server-identities>
            <ssl>
               <keystore path="server-keystore.pfx" keystore-password="secret" alias="infinispan-server"/> 
            </ssl>
         </server-identities>
       </security-realm>
```
* Run the client with `export TEST=SIMPLE && mvn exec:exec`


== Unsigned server keystore with client authorization

=== Apply the configuration
* copy client-keystore.pfx to ${ISPN_HOME}/server/conf
* Add the `server-identities` element as followed, note that the properties realm is removed
```xml
       <security-realm name="default">
         <server-identities>
            <ssl>
               <keystore path="server-keystore.pfx" keystore-password="secret" alias="infinispan-server"/> 
               <truststore path="client-truststore.pfx" password="ClientSecret"/>
            </ssl>
         </server-identities>
       </security-realm>
```
* Force to verify the client certificate, otherwise the client suceeds also without having a client side keystore
  The client connection is now verified, but all used client certificates must be added to the `client-truststore` for the server to accept it.
```xml
   <endpoints socket-binding="default" security-realm="default" require-ssl-client-auth="true"/>
```
* Change the global `authorization`, add the CN role mapper and add roles
```xml
  <security>
    <authorization>
      <common-name-role-mapper/>
      <role name="Client1" permissions="ALL"/>
      <role name="Client2" permissions="READ"/>
    </authorization>
  </security>
</cache-container>
```
* Add the `security` and `authorization` element for the cache as followed
```xml
  <local-cache name="secured">
    <security>
      <authorization/>
    <security>
  </local-cache>
```
* Set the `truststore-realm` for authentication
```xml
  <security-realm name="default">
    <server-identities .../>
    <truststore-realm/>
  </security-realm>
```
* Run the client with `export TEST=SIMPLEAUTH && mvn exec:exec`


== Signed server keystore with client verification
Like external signed certificates, which are recommended for production use, the benefit is that the server does not need to import all dedicated client certificates.
If they are signed with the known CA certificate, the server will trust it.

=== Apply the configuration
* copy server_keystore.p12 to ${ISPN_HOME}/server/conf
* copy server_truststore.p12 to ${ISPN_HOME}/server/conf
* Add the `server-identities` element as followed, note that the properties realm is removed
```xml
       <security-realm name="default">
         <server-identities>
            <ssl>
               <keystore path="server_keystore.p12" keystore-password="Serversecret" alias="infinispan-server"/>
               <truststore path="server_truststore.p12" password="ServerTrustsecret"/>
            </ssl>
         </server-identities>
       </security-realm>
```
* Force to verify the client certificate, otherwise the client suceeds also without having a client side keystore
```xml
   <endpoints socket-binding="default" security-realm="default" require-ssl-client-auth="true"/>
```
* Run the client with `export TEST=CLIENT1,CLIENT2 && mvn exec:exec`
* Check both clients succeed

== User Authorization for the clients certificate

=== Enable the authorization for the cache
* Change the global `authorization`, add the CN role mapper and add roles
```xml
  <security>
    <authorization>
      <common-name-role-mapper/>
      <role name="Client1" permissions="ALL"/>
      <role name="Client2" permissions="READ"/>
    </authorization>
  </security>
</cache-container>
```
* Add the `security` and `authorization` element for the cache as followed
```xml
  <local-cache name="secured">
    <security>
      <authorization/>
    <security>
  </local-cache>
```
* Set the `truststore-realm` for authentication
```xml
  <security-realm name="default">
    <server-identities .../>
    <truststore-realm/>
  </security-realm>
```
* Run the client again with `export TEST=CLIENT1AUTH,CLIENT2AUTH && mvn exex:exec`
   The client will now fail as it is mandatory to have all client certificates available within the truststore
* run `create_signed_server_truststore_auth.sh`
* copy the created `server_truststoreAuth.p12` file to ${ISPN_HOME}/server/conf and change the truststore configuration
* Tune the client again and check that Client1 will succeed and Client2 will fail to put entries as expected.


== Troubleshooting
Note that the server version 12.1.4 is not working correctly for the `common-name-role-mapper` because of link:https://issues.redhat.com/browse/ISPN-13089[ISPN-13089].

If there are unexpected failures it would help to enable `org.wildfly.security` and `org.infinispan.security` logging with TRACE level for the server to see what is going wrong.

If the keytool show a warning for JKS keystores you should update to Java 11 where this is the default, or set the `-deststoretype pkcs12` explicit as this is the recommended standard.
